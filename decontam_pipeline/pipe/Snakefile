"""Megadaph Decontamination Pipeline"""

import os

configfile: "config.yml"

SAMPLE, PAIR = glob_wildcards(
        os.path.join(config['readsdir'], '{sample}.{pair}.fastq.gz'))

if config['isolates'] != 'all':
    # Only include samples from the specified isolates
    if len(config['isolates']) == 1:
        isolates = [config['isolates']]
    else:
        isolates = config['isolates']
    SAMPLE = [x for x in SAMPLE if x.startswith(*isolates)]

STARTCONTROL = [x for x in SAMPLE if 'SC' in x]

rule all:
    input:
        'output/multiqc/multiqc.html'


rule raw_fastqc:
    input:
        fwd_reads = 'input/reads/{sample}.R1.fastq.gz',
        rev_reads = 'input/reads/{sample}.R2.fastq.gz'
    output:
        'output/raw_fastqc/{sample}.R1_fastqc.html',
        'output/raw_fastqc/{sample}.R2_fastqc.html',
    params:
        outdir = 'output/raw_fastqc'
    shell:
        "fastqc -o {params.outdir} {input.fwd_reads} {input.rev_reads}"


rule trim_adapters:
    input:
        fwd_reads = 'input/reads/{sample}.R1.fastq.gz',
        rev_reads = 'input/reads/{sample}.R2.fastq.gz'
    output:
        fwd_reads = 'output/trim_adapters/{sample}.R1.fastq.gz',
        rev_reads = 'output/trim_adapters/{sample}.R2.fastq.gz'
    log: "output/trim_adapters/log/{sample}.log"
    params:
        ref = config['adapters'],
        k = '23',
        ktrim = 'r',
        mink = '4',
        hdist = '1'
    shell:
        "bbduk.sh in={input.fwd_reads} in2={input.rev_reads} threads=1 "
        "out={output.fwd_reads} out2={output.rev_reads} ref={params.ref} "
        "k={params.k} ktrim={params.ktrim} mink={params.mink} "
        "hdist={params.hdist} tpe tbo 2> {log}"


# rule error_correction:
#   input:
#       fwd_reads = rules.trim_adapters.output.fwd_reads,
#       rev_reads = rules.trim_adapters.output.rev_reads
#   output:
#       fwd_reads = 'error_correction/{sample}.R1.fastq.gz',
#       rev_reads = 'error_correction/{sample}.R2.fastq.gz',
#   log: "error_correction/log/{sample}.log"
#   params:
#       k = '50'
#   shell:
#       """
#       tadpole.sh in={input.fwd_reads} in2={input.fwd_reads} \
#           out={output.fwd_reads} out2={output.rev_reads} k={params.k} \
#           mode=correct 2> {log}
#       """

rule merge_reads:
    input:
        fwd_reads = rules.trim_adapters.output.fwd_reads,
        rev_reads = rules.trim_adapters.output.rev_reads
    output:
        fwd_reads = 'output/merge_reads/{sample}.R1.fastq.gz',
        rev_reads = 'output/merge_reads/{sample}.R2.fastq.gz',
        merged_reads = 'output/merge_reads/{sample}.merged.fastq.gz',
        insert_hist = 'output/merge_reads/{sample}.hist'
    log: "output/merge_reads/log/{sample}.log"
    params:
        vstrict = 't'
    shell:
        "bbmerge.sh in1={input.fwd_reads} in2={input.rev_reads} threads=1 "
        "out={output.merged_reads} outu={output.fwd_reads} "
        "outu2={output.rev_reads} ihist={output.insert_hist} "
        "vstrict={params.vstrict} 2> {log}"


rule quality_trim:
    input:
        fwd_reads = rules.merge_reads.output.fwd_reads,
        rev_reads = rules.merge_reads.output.rev_reads,
        merged_reads = rules.merge_reads.output.merged_reads
    output:
        fwd_reads = 'output/quality_trim/{sample}.R1.fastq.gz',
        rev_reads = 'output/quality_trim/{sample}.R2.fastq.gz',
        merged_reads = 'output/quality_trim/{sample}.merged.fastq.gz'
    log:
        paired = "output/quality_trim/log/{sample}.paired.log",
        unpaired = "output/quality_trim/log/{sample}.unpaired.log"
    params:
        qtrim = 'rl',
        trimq = '20',
        minlen = '50'
    shell:
        "bbduk.sh in={input.fwd_reads} in2={input.rev_reads} "
        "out={output.fwd_reads} out2={output.rev_reads} threads=1 "
        "qtrim={params.qtrim} trimq={params.trimq} minlen={params.minlen} "
        "2> {log.paired} &&"
        "bbduk.sh in={input.merged_reads} out={output.merged_reads} threads=1 "
        "qtrim={params.qtrim} trimq={params.trimq} minlen={params.minlen} "
        "2> {log.unpaired}"


rule clean_fastqc:
    input:
        fwd_reads = rules.quality_trim.output.fwd_reads,
        rev_reads = rules.quality_trim.output.rev_reads,
        merged_reads = rules.quality_trim.output.merged_reads
    output:
        'output/clean_fastqc/{sample}.R1_fastqc.html',
        'output/clean_fastqc/{sample}.R2_fastqc.html',
        'output/clean_fastqc/{sample}.merged_fastqc.html'
    params:
        outdir='output/clean_fastqc'
    shell:
        "fastqc -o {params.outdir} {input.fwd_reads} {input.rev_reads} "
        "{input.merged_reads}"


rule multiqc:
    input:
        expand('output/clean_fastqc/{sample}.R1_fastqc.html', sample=SAMPLE),
        expand('output/clean_fastqc/{sample}.R2_fastqc.html', sample=SAMPLE),
        expand(
            'output/clean_fastqc/{sample}.merged_fastqc.html', sample=SAMPLE),
        expand('output/raw_fastqc/{sample}.R1_fastqc.html', sample=SAMPLE),
        expand('output/raw_fastqc/{sample}.R2_fastqc.html', sample=SAMPLE)
    output: 'output/multiqc/multiqc.html'
    shell:
        'multiqc -d -n {output} .'


rule initial_assembly:
    input:
        fwd_reads = expand(
            'output/quality_trim/{sample}.R1.fastq.gz', sample=STARTCONTROL),
        rev_reads = expand(
            'output/quality_trim/{sample}.R2.fastq.gz', sample=STARTCONTROL)
    params:
        threads='8',
        output_dir='initial_assembly/{sample}_spades'
    output:
        'output/initial_assembly/{sample}.fasta'
    shell:
        "python2 {config['spades_executable']} -1 {input.fwd_reads} -2 "
        "-2 {input.rev_reads} --threads {params.threads} -o "
        "{params.output_dir} &&"
        "mv {params.output_dir}/scaffolds.fasta {params.output}"
